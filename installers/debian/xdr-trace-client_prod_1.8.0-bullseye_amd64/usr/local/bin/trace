#!/usr/bin/env python3

# Copyright   : Whizhack Technologies Pvt Ltd
# Author      : Amisha Prashar
# Description : This is the automation script for xdr-trace-client version 1.8.0 installation.
# Usage       : Run this script using command sudo trace [options], for options see the "read_me" section 
# Version     : 1.8.0

import subprocess
import sys
import random
import yaml
import socket
import requests
import json
import ast
import string
import time
import os

# Helping section for xdr-trace-client version 1.8.0 installation
def read_me():
    print('''
===========================================================================================
Welcome to xdr-trace Automated Installer Help Section:-                                      
Available Flag Options are below :                                                      
                                                                                       
-i | install              : Fresh Installation of xdr-trace client version 1.8.0        
-u | uninstall            : Uninstall xdr-trace client version 1.8.0 
-y | credentialRefresh    : To Update AWS-Credentials
-r | reconfigure          : Reconfigure the Installation of xdr-trace client version 1.8.0                              
-h | help                 : Help Section for xdr-trace-client version 1.8.0             
===========================================================================================
''')
    

# Converting config.yml into config.env 
def create_env_file(yaml_file_path, env_file_path):
    with open(yaml_file_path, 'r') as yaml_file:
        config = yaml.safe_load(yaml_file)

    # Getting public and private IP of machine
    try:
        result = subprocess.run(["curl", "ifconfig.me"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)
        public_ip = result.stdout.strip()
        config["PUBLIC_IP"] = public_ip
    except subprocess.CalledProcessError:
        private_ip = socket.gethostbyname(socket.gethostname())
        config["PUBLIC_IP"] = private_ip
         
    with open(env_file_path, 'w') as env_file:
        for key, val in config.items():
            env_file.write(f"{key}={val}\n")
    
# Updating the Sensor Name in the config.yml file.
def sensor_name_env(selected_sensor, env_file_path):            
    with open(env_file_path, "r") as file:
        lines = file.readlines()

    # Finding the line that contains SENSOR_NAME and update its value
    updated_lines = []
    for line in lines:
        if line.startswith("SENSOR_NAME="):
            updated_lines.append("SENSOR_NAME=" + selected_sensor + "\n")
        else:
            updated_lines.append(line)

    # Write the updated content back to the file
    with open(env_file_path, "w") as file:
        file.writelines(updated_lines)
         
# Initializing xdr-trace-net.service
def service_init():
    print("[i] Initializing xdr-trace-net.service. This usually takes around 5 minutes. If it takes longer then you have internet issues. (The duration can be longer for active directory services)")
    
    subprocess.run(["sudo", "systemctl", "enable", "xdr-trace-net"])
    subprocess.run(["sudo", "systemctl", "start", "xdr-trace-net"])
    print("[i] xdr-trace-net.service successfully initialized.")
    
    subprocess.run(["sudo", "systemctl", "enable", "xdr-trace-health"])
    subprocess.run(["sudo", "systemctl", "start", "xdr-trace-health"])
    print("[i] xdr-trace-health.service successfully initialized.")
    
# Configuring AWS
def aws_setup():
    # Loading the YAML file
    with open('/etc/zh-xdr-trace-client/config.yml', 'rb') as f:
        config = yaml.safe_load(f)
    
    # Accessing the variables
    aws_default_region  = config['AWS_DEFAULT_REGION']
    access_key_id       = config['AWS_ACCESS_KEY_ID']
    secret_access_key   = config['AWS_SECRET_ACCESS_KEY']
    
    # Configuring the awscli to use the provided credentials.
    subprocess.run(["sudo", "aws", "configure", "set", "region", aws_default_region])
    subprocess.run(["sudo", "aws", "configure", "set", "aws_access_key_id", access_key_id])
    subprocess.run(["sudo", "aws", "configure", "set", "aws_secret_access_key", secret_access_key])
    
    login_pass = subprocess.check_output(["sudo", "aws", "ecr", "get-login-password", "--region", "us-east-2"]).decode("utf-8")

    subprocess.check_call(["sudo", "docker", "login" , "-u", "AWS" , "406116439221.dkr.ecr.us-east-2.amazonaws.com" , "--password", login_pass])

def get_service_status():
    try:
        # Use the 'systemctl' command to check the service status
        status1 = os.system(f'sudo systemctl is-active --quiet xdr-trace-net')
        status2 = os.system(f'sudo systemctl is-active --quiet xdr-trace-health')
        if status1 == 0 and status2 == 0:  #768 means not runnning, 0 means runnng
            print("[i] Both services are running.")
            ############# sensor active count ##############
            filename = '/etc/zh-xdr-trace-client/config.yml'
            with open(filename, 'r') as config_file:
                config = yaml.safe_load(config_file)
            sensorkey = config['SENSOR_ACCESS_ID']
            control_server_domain = config['CONTROL_SERVER_DOMAIN']
            api_url = f'{control_server_domain}/api/multiple-decrease-license-count'
            headers = {
                'sensorkey': sensorkey ,
                'deccount': '1'
            }
            response = requests.post(api_url, headers=headers)
            ##################################################
        else:
            print("[!] One or both services are not running.")
    except subprocess.CalledProcessError as e:
        # Handle the case when the service is not found or other errors occur
        return f"Error: {e}"

# Installing xdr-trace-client version 1.8.0  
def install():
    filename = "/etc/zh-xdr-trace-client/config.yml"  
    license_check(filename)
    try:
        response = input("File named 'config.yml' located at /etc/zh-xdr-trace-client/ is configured? (Y/n) ")

        if response == "Y" or response == "y" or response == "":
            print("[i] Initializing the installation process..")

            # providing file paths and creating config.env file
            yaml_file_path  = '/etc/zh-xdr-trace-client/config.yml'
            env_file_path   = '/etc/zh-xdr-trace-client/config.env'
            create_env_file(yaml_file_path, env_file_path)

            with open(yaml_file_path, 'r') as config_file:
                config = yaml.safe_load(config_file)

            # Assuming SENSOR_NAME is a key in the config YAML
            sensor_names = config.get('SENSOR_NAME', [])

            if not sensor_names:
                print("No sensor names found in the configuration.")
            else:
                selected_sensor = random.choice(sensor_names)
                selected_sensor1 = selected_sensor + ".yml"
                arguments = [
                    "sudo",
                    "ln",
                    "-s",
                    "/opt/zh-xdr-trace-client/honeynets/" + selected_sensor1,  
                    "/opt/zh-xdr-trace-client/compose/trace-net.yml"
                ] 
                subprocess.run(arguments, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                sensor_name_env(selected_sensor, env_file_path)

            aws_setup()
            service_init()
            time.sleep(60)
            get_service_status()
            
            print("[i] Installation process completed successfully.")
            print("[i] You can run 'sudo docker ps' to check the running containers.")
            print("[i] Meanwhile, you can access XDR threat dashboard at https://xdr-demo.zerohack.in.")
        else:
            print("[!] Kindly fill the configuration file located at /etc/zh-xdr-trace-client/config.yml")
            exit()

    except Exception as e:
        print("[!] An error occurred during the installation process:")
        print(e)
         
# Uninstalling xdr-trace-client version 1.8.0  
def uninstall():
    filename  = '/etc/zh-xdr-trace-client/config.yml'
    with open(filename, 'r') as config_file:
        config = yaml.safe_load(config_file)
    sensorkey = config['SENSOR_ACCESS_ID']
    control_server_domain = config['CONTROL_SERVER_DOMAIN']
    api_url = f'{control_server_domain}/api/multiple-decrease-license-count'
    headers = {
        'sensorkey': sensorkey ,
        'inccount': '1'
    }
    response = requests.post(api_url, headers=headers)
    subprocess.run(["sudo", "systemctl", "stop", "xdr-trace-net"])
    subprocess.run(["sudo", "systemctl", "disable", "xdr-trace-net"])
    subprocess.run(["sudo", "systemctl", "stop", "xdr-trace-health"])
    subprocess.run(["sudo", "systemctl", "disable", "xdr-trace-health"])
    subprocess.run(["sudo", "rm", "-r", "/etc/zh-xdr-trace-client"])
    subprocess.run(["sudo", "rm", "-r", "/opt/zh-xdr-trace-client"])
    subprocess.run(["sudo", "apt", "autopurge", "zh-xdr-trace-client", "-y"])
    subprocess.run(["sudo", "systemctl", "daemon-reload"])


# Reconfiguring xdr-trace-client version 1.8.0  
def reconfigure():
    try:    
        #Prompting the user to fill the configuration file
        response = input("Do you want to reconfigure the trace setup? (Y/n) ")

        if response == "Y" or response == "y":
            print("[i] Initializing the reconfigure process..")
            # providing file paths and creating config.env file
            yaml_file_path  = '/etc/zh-xdr-trace-client/config.yml'
            env_file_path   = '/etc/zh-xdr-trace-client/config.env'
            create_env_file(yaml_file_path, env_file_path)
            
            with open(yaml_file_path, 'r') as config_file:
                config = yaml.safe_load(config_file)

            # Assuming SENSOR_NAME is a key in the config YAML
            sensor_names = config.get('SENSOR_NAME', [])

            if not sensor_names:
                print("No sensor names found in the configuration.")
            else:
                selected_sensor = random.choice(sensor_names)
                selected_sensor1 = selected_sensor + ".yml"
                arguments = [
                    "sudo",
                    "ln",
                    "-s",
                    "/opt/zh-xdr-trace-client/honeynets/" + selected_sensor1,  
                    "/opt/zh-xdr-trace-client/compose/trace-net.yml"
                ]
                subprocess.run(arguments, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                sensor_name_env(selected_sensor, env_file_path)
                
            credential_refresh()    
            aws_setup()
            subprocess.run(["sudo", "systemctl", "restart", "xdr-trace-net"])
            subprocess.run(["sudo", "systemctl", "restart", "xdr-trace-health"])
            print("[i] Reconfigure process completed successfully.")
            print("[i] You can run 'sudo docker ps' to check the running containers.")
            print("[i] Meanwhile, you can access XDR threat dashboard at https://xdr-demo.zerohack.in.")
        else:
            print("[!] Kindly fill the configuration file located at /etc/zh-xdr-trace-client/config.yml")
            exit()
    except Exception as e:
            print("[!] An error occurred during the installation process:")
            print(e)        
        
# Updating aws credentials 
def credential_refresh():
    # Updating the awscli.
    subprocess.run(["sudo", "/aws/install", "--update"], check=True)

    # Logging into the repository.
    region          = "us-east-2"
    repository      = "406116439221.dkr.ecr.us-east-2.amazonaws.com"

    get_login_cmd   = ["sudo", "aws", "ecr", "get-login-password", "--region", region]
    login_cmd       = ["sudo", "docker", "login", "--username", "AWS", "--password-stdin", repository]

    get_login_password_process = subprocess.Popen(get_login_cmd, stdout=subprocess.PIPE)
    password, _ = get_login_password_process.communicate()

    login_process = subprocess.Popen(login_cmd, stdin=subprocess.PIPE)
    login_process.communicate(input=password)
    
# Cleaning process on reboot 
def reboot_cleanup(): 
    commands = [
        ["sudo", "systemctl", "stop", "xdr-trace-net"],
        ["sudo", "docker", "container", "stop"] + subprocess.check_output(["docker", "container", "ls", "-aq"]).decode().split(),
        ["sudo", "docker", "container", "rm"] + subprocess.check_output(["docker", "container", "ls", "-aq"]).decode().split(),
        ["sudo", "docker", "system", "prune", "-f"],
        ["sudo", "docker", "volume", "prune", "-f"],
        ["sudo", "docker", "network", "prune", "-f"],
        ["sudo", "docker", "volume", "rm"] + subprocess.check_output(["docker", "volume", "ls", "-q"]).decode().split() + ["-f"],
        ["sudo", "docker", "network", "rm"] + subprocess.check_output(["docker", "network", "ls", "-q"]).decode().split()
    ]

    for cmd in commands:
        subprocess.run(cmd)  

# Randomizing the Honeynets 
def honeynet_reset():
    try:
        # providing file paths and creating config.env file
        yaml_file_path  = '/etc/zh-xdr-trace-client/config.yml'
        env_file_path   = '/etc/zh-xdr-trace-client/config.env'
        create_env_file(yaml_file_path, env_file_path)
        
        with open(yaml_file_path, 'r') as config_file:
            config = yaml.safe_load(config_file)
        # Assuming SENSOR_NAME is a key in the config YAML
        sensor_names = config.get('SENSOR_NAME', [])
        if not sensor_names:
            print("[i] No sensor names found in the configuration.")
        else:
            selected_sensor = random.choice(sensor_names)
            selected_sensor1 = selected_sensor + ".yml"
            arguments = [
                "sudo",
                "ln",
                "-s",
                "/opt/zh-xdr-trace-client/honeynets/" + selected_sensor1,  
                "/opt/zh-xdr-trace-client/compose/trace-net.yml"
            ]
            subprocess.run(arguments, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            sensor_name_env(selected_sensor, env_file_path)
            
        credential_refresh()        
        aws_setup()
        subprocess.run(["sudo", "systemctl", "restart", "xdr-trace-net"])
        subprocess.run(["sudo", "systemctl", "restart", "xdr-trace-health"])         
    except Exception as e:
            print("[!] An error occurred during the installation process:")
            print(e)        

# Cleaning process of Trace 
def update_cleanup():
    commands = [
        ["sudo", "systemctl", "stop", "xdr-trace-net"],
        ["sudo", "apt", "update"],
        ["sudo", "apt", "upgrade", "-y"],
        ["sudo", "apt", "autoremove", "-y"],
        ["sudo", "apt", "clean"],
        ["sudo", "docker", "container", "stop"] + subprocess.check_output(["docker", "container", "ls", "-aq"]).decode().split(),
        ["sudo", "docker", "container", "rm"] + subprocess.check_output(["docker", "container", "ls", "-aq"]).decode().split(),
        ["sudo", "docker", "system", "prune", "-af"],
        ["sudo", "docker", "volume", "prune", "-f"],
        ["sudo", "docker", "network", "prune", "-f"],
        ["sudo", "docker", "rmi"] + subprocess.check_output(["docker", "images", "-aq"]).decode().split() + ["-f"], 
    ]
    for cmd in commands:
        subprocess.run(cmd)   

# Genearting Random ID
def random_id():
    characters = string.ascii_letters + string.digits
    random_string = ''.join(random.choice(characters) for _ in range(10))
    return random_string


# Checking License 
def license_check(filename):
    # This license check function is checking whether the particular sensor key is allowed for installing the xdr-trace-client or not. 
    # If the sensor key matches with the key present in our database then only installation process intializes.
    # In case of mismatch user/client will not be able to install the package.
    with open(filename, 'r') as config_file:
        config = yaml.safe_load(config_file)
    if 'SENSOR_ACCESS_ID' in config:
        sensorkey = config['SENSOR_ACCESS_ID']
        control_server_domain = config['CONTROL_SERVER_DOMAIN']
    else:
        sensorkey = None
        control_server_domain = None
    api_url = f'{control_server_domain}/api/display-multiple-decrease-license-count'
    headers = {"sensorkey": sensorkey}
    response = requests.get(api_url, headers=headers)

    if response.status_code == 200:
        api_data = response.json()
        for key in api_data:
            if key == "TRACE":
                api_key = key
        dict = api_data[api_key]
        aggregator_domain = dict['aggregator_domain']
        aggregator_port = dict['aggregator_port']
        sensor_type = dict['sensor_type']
        registry_server = dict['registry_server']
        access_id = dict['access_id']
        access_key = dict['access_key']
        edition = dict['edition']
        location = dict['location']
        client_city = dict['client_city']
        client_latitude = dict['client_latitude']
        client_longitude = dict['client_longitude']
        client_country_code = dict['client_country_code']
        client_country_name = dict['client_country_name']
        license_start_date = dict['license_start_date']
        license_end_date = dict['license_end_date']
        xdr_trace_status = dict['xdr_trace_status']
        diss_status = dict['diss_status']
        diss_mode = dict['diss_mode']
        data_sharing_mode = dict['data_sharing_mode']
        operating_env = dict['operating_env']
        sensor_create_count = dict['sensor_create_count']
        xdr_default_region = dict['xdr_default_region']
        company_index_name = dict['company_index_name']
        sensor_names_tuple = dict['sensor_name']
        sensor_names_tuple = ast.literal_eval(sensor_names_tuple)
        sensor_names_list = list(sensor_names_tuple)
        sensor_id = random_id()
         
        if xdr_trace_status == 'active':
            # Reading the original config.yml content
            with open(filename, 'r') as config_file:
                config_content = config_file.read()
            keys_to_update = {
                "AGGREGATOR_DOMAIN: \"\"": f"AGGREGATOR_DOMAIN: \"{aggregator_domain}\"",
                "AGGREGATOR_PORT: \"\"": f"AGGREGATOR_PORT: \"{aggregator_port}\"",
                "SENSOR_TYPE: \"\"": f"SENSOR_TYPE: \"{sensor_type}\"",
                "REGISTRY_SERVER: \"\"": f"REGISTRY_SERVER: \"{registry_server}\"",
                "AWS_ACCESS_KEY_ID: \"\"": f"AWS_ACCESS_KEY_ID: \"{access_id}\"",
                "AWS_SECRET_ACCESS_KEY: \"\"": f"AWS_SECRET_ACCESS_KEY: \"{access_key}\"",
                "EDITION: \"\"": f"EDITION: \"{edition}\"",
                "LOCATION: \"\"": f"LOCATION: \"{location}\"",
                "CLIENT_CITY: \"\"": f"CLIENT_CITY: \"{client_city}\"",
                "CLIENT_LATITUDE: \"\"": f"CLIENT_LATITUDE: \"{client_latitude}\"",
                "CLIENT_LONGITUDE: \"\"": f"CLIENT_LONGITUDE: \"{client_longitude}\"",
                "CLIENT_COUNTRY_CODE: \"\"": f"CLIENT_COUNTRY_CODE: \"{client_country_code}\"",
                "CLIENT_COUNTRY_NAME: \"\"": f"CLIENT_COUNTRY_NAME: \"{client_country_name}\"",
                "LICENSE_START_DATE: \"\"": f"LICENSE_START_DATE: \"{license_start_date}\"",
                "LICENSE_END_DATE: \"\"": f"LICENSE_END_DATE: \"{license_end_date}\"",
                "XDR_TRACE_STATUS: \"\"": f"XDR_TRACE_STATUS: \"{xdr_trace_status}\"",
                "DISS_STATUS: \"\"": f"DISS_STATUS: \"{diss_status}\"",
                "DISS_MODE: \"\"": f"DISS_MODE: \"{diss_mode}\"",
                "DATA_SHARING_MODE: \"\"": f"DATA_SHARING_MODE: \"{data_sharing_mode}\"",
                "OPERATING_ENV: \"\"": f"OPERATING_ENV: \"{operating_env}\"",
                "SENSOR_CREATE_COUNT: \"\"": f"SENSOR_CREATE_COUNT: \"{sensor_create_count}\"",
                "AWS_DEFAULT_REGION: \"\"": f"AWS_DEFAULT_REGION: \"{xdr_default_region}\"",
                "COMPANY_INDEX_NAME: \"\"": f"COMPANY_INDEX_NAME: \"{company_index_name}\"",
                "SENSOR_ID: \"\"": f"SENSOR_ID: \"{sensor_id}\""
            }
            # Updating the values in the content
            updated_content = config_content
            for old_key, new_key in keys_to_update.items():
                updated_content = updated_content.replace(old_key, new_key)
            # Writing the updated content back to the file
            with open(filename, 'w') as config_file:
                config_file.write(updated_content)
        
            ############### sensor name update #################   
            # Read the original file
            with open(filename, 'r') as file:
                lines = file.readlines()
            # Find the line where SENSOR_NAME is located
            sensor_name_line_index = None
            for i, line in enumerate(lines):
                if line.strip() == "SENSOR_NAME:":
                    sensor_name_line_index = i
                    break
            if sensor_name_line_index is not None:
                # Insert the sensor names into the SENSOR_NAME section
                lines[sensor_name_line_index + 1:sensor_name_line_index + 1] = [f'  - "{name}"\n' for name in sensor_names_list]

            # Write the modified content back to the file
            with open(filename, 'w') as file:
                file.writelines(lines)   
                 
            print("Info: Config.yml updated with data from the database.")
            
        else:
            print("Info: Invalid Sensor ID is Provided.")
            sys.exit()    
    else:
        print(f"Failed to retrieve data. Status code: {response.status_code}")
        sys.exit() 
        
# Main Function  
def main():
    n = len(sys.argv)
    if n == 1:
        read_me()
    elif n == 2:  
        arg = sys.argv[1]
        if arg in ("-i", "install"):
            install()   
            sys.exit()
        elif arg in ("-u", "uninstall"):
            uninstall()
            sys.exit()
        elif arg in ("-y", "credentialRefresh"):
            credential_refresh()
            sys.exit()    
        elif arg in ("-r", "reconfigure"):
            reconfigure()
            sys.exit()
        elif arg in ("-t", "reset"):
            honeynet_reset()    
            sys.exit()   
        elif arg in ("-h", "help"):
            read_me()
            sys.exit()    
            
# Calling Main Function        
main()

